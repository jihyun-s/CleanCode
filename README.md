# Clean Code

## 2장 의미있는 이름 
### 1. 나쁜 코드
    - 성능이 나쁜 코드 : 불필요한 연산이 들어가서 개선의 여지가 있는 코드
    - 의미가 모호한 코드 : 이해하기 어려운 코드. 네이밍과 그 내용이 다른 코드 
    - 중복된 코드 : 비슷한 내용인데 중복되는 코드 

    (-) 깨진 유리창처럼 계속 나쁜 코드가 만들어지도록 한다.
    (-) 생산성 저하 (기술부채)
    (-) 새로운 시스템을 만들어야 한다. (현시스템 유지보수 어렵기 때문)


### 2. 클린 코드
    - 성능이 좋은 코드
    - 의미가 명확한 코드 = 가독성이 좋은 코드
    - 중복이 제거된 코드


### 3. 의미 있는 이름 짓기 
    - 루프 속 i j k 사용하지 않기 (advaned for문으로 대체, lamda 사용, 맥락에 맞는 이름 사용) 
    - 통일성 있는 단어 사용하기 
    - 변수명에 타입 넣지 않기 
    
    
### 4. Google Java Naming Guide
    - Package Naming Guide : All lover case, no underscores
    - Class Naming Guide : UppderCamelCase (대문자로 시작) 
        - 클래스는 명사, 명사구
        - 인터페이스는 명사, 명사구, (형용사) 
        - 테스트 클래스는 Test로 끝나기 
    - Method Naming Guide : LowerCamelCase (소문자로 시작) 
        - 메서드는 동사, 동사구 
        - jUnit 테스트에 underscore 사기도 함 


## 3장 함수 

### 1. SOLID
    - SRP (단일 책임 원칙) : 한 클래스는 하나의 책임만 가져야 한다.
        - 클래스는 하나의 기능만 가지며, 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다. 
        - SRP 책임이 분명해지기 때문에, 변경에 의한 연쇄작용에서 자유로워질 수 있다. 
        - 가독성 향상과 유지보수가 용이해진다. 
        - 실전에서는 쉽지 않지만 늘 상기해야 한다. 
        
    - OCP (개방-폐쇄 원칙) :  소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. 
        - 변경을 위한 비용은 가능한 줄이고, 확장을 위한 비용은 가능한 극대화 해야 한다. 
        - 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소에는 수정이 일어나지 않고, 기존 구성 요소를 쉽게 확장해서 재사용한다. 
        - 객체지향의 추상화와 다형성을 활용한다. 
        
    - LSP (리스코프 치환 원칙) : 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다. 
        - 서브 타입은 기반 타입이 약속한 규약(접근제한자, 예외 포함)을 지켜야 한다. 
        - 클래스 상속, 인터페이스 상속을 이용해 확장성을 획득한다. 
        - 다형성과 확장성을 극대화하기 위해 인터페이스를 사용하는 것이 더 좋다. 
        - 합성(composition)을 이용할 수도 있다. 
        
    - ISP (인터페이스 분리 원칙) : 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 
        - 가능한 최소한의 인터페이스만 구현한다. 
        - 만약 어떤 클래스를 이용하는 클라이언트가 여러 개고, 이들이 클래스의 특정 부분만 이용한다면, 여러 인터페이스로 분류하여 클라이언트가 필요한 기능만 전달한다. 
        - SRP가 클래스의 단일 책임이라면, ISP는 인터페이스의 단일 책임 
        
    - DIP (의존성 역전 원칙) : 상위 모델은 하위 모델에 의존하면 안 된다. 둘 다 추상화에 의존해야 한다. 추상화는 세부사항에 의존해서는 안 된다. 세부 사항은 추상화에 따라 달라진다.
        - 하위 모델의 변경이 상위 모듈의 변경을 요구하는 위계관계를 끊는다. 
        - 실제 사용관계는 그대로이지만, 추상화를 매개로 메시지를 주고 받으면서 관계를 느슨하게 만든다. 
    
    
### 2. 간결한 함수 작성하기
    - 작게 쪼갠다. 
    - 함수 내 추상화 수준을 동일하게 맞춘다. 
    - 한 가지만 하기(SRP), 변경에 닫게 만들기(OCP) : 계산과 타입관리를 분리, 타입에 대한 처리는 최대한 Factory에서만 
    - 함수 인수 : 인수의 갯수는 0~2개가 적당하다. 3개 이상인 경우에는 객체를 인자로 넘기기 
    
### 3. 안전한 함수 작성하기 
    - 부수 효과(Side Effect) 없는 함수 : 값을 반환하는 함수가 외부 상태를 변경하는 경우 

### 4. 함수 리팩터링 
    - 기능을 구현하는 서투른 함수를 작성한다. (길고, 복잡하고, 중복도 있다.) 
    - 테스트 코드를 작성한다. (함수 내부의 분기와 엣지값마다 빠짐없이 테스트하는 코드를 짠다.) 
    - 리팩터링한다. (코드를 다듬고, 함수를 쪼개고, 이름을 바꾸고, 중복을 제거한다.) 
    

## 4장 주석

### 1. 주석을 최대한 쓰지 말자
    - 주석은 나쁜 코드를 보완하지 못한다. 
        - 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다. 
        - 코드로도 의도를 표현할 수 있다. (ex. 의미있는 이름으로 짓기)
    - 주석은 방치된다.
        - 코드의 변화에 따라가지 못하고, 주석은 방치된다. 
        - 코드는 컴파일되어 호출되지만, 주석은 그저 주석이기 때문에 그 자리에 방치되고 결국 의미없는 텍스트가 되어버린다. 

### 2. 좋은 주석
    - 구현에 대한 정보를 제공한다. 
    - 의도와 중요성을 설명한다. 
    - TODO : 앞으로 할 일. 지금은 해결하지 않지만 나중에 해야할 일을 미리 적어줄 때. 
    - FIXME : 문제가 있지만, 당장 수정할 필요는 없을 때. 가능하면 빨리 수정하는게 좋다.  

### 3. 주석보다 annotation 
    - annotation = 코드에 대한 메타 데이터
    - 코드의 실행 흐름에 간섭을 주기도 하고, 주석처럼 코드에 대한 정보를 줄 수 있다. 
        - @Deprecated : 컴파일러가 warning을 발생시킴. IDE에서 사용시 표시됨
        - @NotThreadSafe : Thread Safe하지 않음을 나타냄

### 4. JavaDoc
    - Java 코드에서 API문서를 HTML 형식으로 생성해주는 도구 
    /**
    * This is a Javadoc
    */
    
    
## 5장 형식 맞추기

### 1. 포맷팅이 중요한 이유
    - 가독성에 필수적이다

### 2. 클린코드 포맷팅 
    - 적절한 길이 유지 (~200라인, <500라인)
        - 200라인을 넘억나다면 클래스가 여러 일을 하고 있을 수 있다. SRP 위배 
    - 밀접한 개념은 서로 가까이 둔다 
        - 행 묶음은 완결된 생각 하나를 표현하기 때문에 개념은 빈 행으로 분리한다.
        - 변수는 사용되는 위치에서 최대한 가까이 선언한다. 

### 3. Java Class Declarations 
    - Class 내부 코드 순서
        1. static 변수 : public -> protected -> package -> private 순서 
        2. instance 변수 : public -> protected -> package -> private 순서
        3. 생성자 
        4. 메서드 : public 메서드에서 호출되는 private 메서드는 그 아래에 둔다. 가독성 위주로 그룹핑한다. 

### 4. Team Coding Convention
    - 팀의 코딩 스타일에 관한 약속
    - 참고
        - Google Java Style Guide : https://google.github.io/styleguide/javaguide.html
        - Naver Hackday Java Convention : https://naver.github.io/hackday-conventions-java/


## 6장 객체와 자료구조 

### 1. 자료구조 vs 객체
    - 자료구조(Data Structure) 
        - 데이터 그 자체 
        - 자료를 공개한다. 
        - 변수 사이에 조회 함수와 설정 함수로 변수를 다룬다고 객체가 되지 않는다. (getter, setter) 
    - 객체(Object)
        - 비즈니스 로직과 관련
        - 자료를 숨기고, 추상화한다. 자료를 다루는 함수만 공개한다.
        - 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있다.
        
    - 상황에 맞는 선택을 하면 된다.
        - 자료구조를 사용하는 절차적인 코드는 기본 자료구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 
        - 절차적인 코드는 새로운 자료구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 
        - 객체지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. 
        - 객체지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다. 

### 2. 객체 - 디미터 법칙
    - 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다.
        - 클래스 C
        - 자신이 생성한 객체 
        - 자신의 인수로 넘어온 객체 
        - C 인스턴스 변수에 저장된 객체 
<img src="https://github.com/jihyun-s/CleanCode/blob/main/object.png" width="55%" height="55%"></img>

### 3. DTO 
    - Data Transfer Object = 자료구조 
    - 다른 계층 간 데이터를 교환할 때 사용
        - 로직없이 필드만 갖는다. 
        - 일반적으로 클래스명이 Dto(or DTO)로 끝난다. 
        - getter/setter를 갖기도 한다. 
    * Beans 
    Java Beans : 데이터 표현이 목적인 자바 객체 
        - 멤버 변수는 private 속성이다. 
        - getter와 setter를 가진다.

### 4. Active Record 
    - Database row를 객체에 맵핑하는 패턴 
        - 비즈니스 로직 메서드를 추가해 객체로 취급하는 건 바람직하지 않다. 
        - 비즈니스 로직을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다. 
        - 하지만 객체가 많아지면 복잡하고, 가까운 곳에 관련 로직이 있는 것이 좋으므로 현업에서는 Entity에 간단한 메서드를 추가해 사용한다. 
    
    * Active Record
        - 객체가 row를 담을 뿐 아니라 database에 대한 접근을 포함한다. 
        - Person의 속성을 담을 뿐 아니라, 생성,수정도 객체 안에서 수행할 수 있다. 
    
    * Data Mapper 
        - row를 담는 객체와 database에 접근할 수 있는 객체가 분리되어 있다. 
        - Person은 값만 담고 있고, 생성, 수정 등 액션은 Person Mapper에서 담당한다. 
        
